// pseudocode/avl/getArbolAVLCode.ts
import { OperationCode } from "./typesPseudoCode";

/**
 * Pseudocódigo de Árbol 1-2-3 (2-3)
 * Nodo2-3:
 *   keys: lista ordenada de T (tamaño 1..2)
 *   child: arreglo de hijos (tamaño 0..3)  // child.length = keys.length + 1 cuando no es hoja
 *   isLeaf(): boolean
 */
export const getArbol123Code = (): OperationCode => ({
  insert: [
    `/**`,
    ` * Inserta un valor en el Árbol 1-2-3.`,
    ` * Si un nodo queda con 3 claves tras insertar, se hace split y`,
    ` * se PROMUEVE la clave del medio hacia el padre.`,
    ` */`,
    `public void insert(T valor) {`,
    `    if (raiz == null) {`,
    `        raiz = new Nodo23<T>();`,
    `        raiz.keys.add(valor);`,
    `        return;`,
    `    }`,
    `    // La inserción devuelve un posible "split" de la raíz`,
    `    Split<T> s = insertarRec(raiz, valor);`,
    `    if (s != null) {`,
    `        // Nueva raíz con la clave promovida`,
    `        Nodo23<T> nueva = new Nodo23<T>();`,
    `        nueva.keys.add(s.promoted);`,
    `        nueva.child[0] = s.left;`,
    `        nueva.child[1] = s.right;`,
    `        raiz = nueva;`,
    `    }`,
    `}`,
    ``,
    `/** Inserta en (n).`,
    ` * Devuelve null si NO hubo split;`,
    ` * o Split{ left, promoted, right } si el nodo se partió.`,
    ` */`,
    `private Split<T> insertarRec(Nodo23<T> n, T v) {`,
    `    if (n.isLeaf()) {`,
    `        insertarOrdenado(n.keys, v);           // ignora duplicados si ya existe`,
    `    } else {`,
    `        int i = posicionDescenso(n.keys, v);   // 0..keys.size`,
    `        Split<T> s = insertarRec(n.child[i], v);`,
    `        if (s != null) {`,
    `            // insertar clave promovida y reconectar hijos`,
    `            insertarOrdenado(n.keys, s.promoted);`,
    `            // al insertar, la promoted queda en índice k`,
    `            int k = indiceDe(n.keys, s.promoted);`,
    `            // desplazar hijos y poner left/right`,
    `            shiftRight(n.child, k+1);`,
    `            n.child[k]   = s.left;`,
    `            n.child[k+1] = s.right;`,
    `        }`,
    `    }`,
    ``,
    `    if (n.keys.size() <= 2) return null;      // aún es 2-3 válido`,
    ``,
    `    // SPLIT: 3 claves -> promover la central`,
    `    T k0 = n.keys.get(0);`,
    `    T k1 = n.keys.get(1); // promovida`,
    `    T k2 = n.keys.get(2);`,
    ``,
    `    Nodo23<T> L = new Nodo23<T>();`,
    `    L.keys.add(k0);`,
    `    Nodo23<T> R = new Nodo23<T>();`,
    `    R.keys.add(k2);`,
    ``,
    `    if (!n.isLeaf()) {`,
    `        // repartir hijos: [c0,c1] -> L, [c2,c3] -> R`,
    `        L.child[0] = n.child[0]; L.child[1] = n.child[1];`,
    `        R.child[0] = n.child[2]; R.child[1] = n.child[3];`,
    `    }`,
    ``,
    `    return new Split<T>(L, k1, R);`,
    `}`,
  ],

  delete: [
    `/**`,
    ` * Elimina un valor del Árbol 1-2-3.`,
    ` * Si un nodo queda con 0 claves, se corrige con REDISTRIBUCIÓN o FUSIÓN`,
    ` * (tomar de hermano con 2 claves, o unir hermanos y bajar una clave del padre).`,
    ` */`,
    `public void delete(T valor) {`,
    `    if (raiz == null) return;`,
    `    eliminarRec(raiz, valor);`,
    `    // Si la raíz quedó vacía y tiene un hijo, desciende la raíz`,
    `    if (raiz.keys.size() == 0 && !raiz.isLeaf()) raiz = raiz.child[0];`,
    `    if (raiz.keys.size() == 0 && raiz.isLeaf())  raiz = null;`,
    `}`,
    ``,
    `private void eliminarRec(Nodo23<T> n, T v) {`,
    `    int idx = buscarEnNodo(n.keys, v);     // -1 si no está en este nodo`,
    `    if (idx != -1) {`,
    `        if (n.isLeaf()) {`,
    `            n.keys.remove(idx);`,
    `        } else {`,
    `            // Reemplazar por predecesor o sucesor para eliminar en hoja`,
    `            Nodo23<T> pred = n.child[idx];`,
    `            while (!pred.isLeaf()) pred = pred.child[pred.keys.size()];`,
    `            T reemplazo = pred.keys.get(pred.keys.size()-1);`,
    `            n.keys.set(idx, reemplazo);`,
    `            eliminarRec(n.child[idx], reemplazo);`,
    `        }`,
    `    } else {`,
    `        if (n.isLeaf()) return;`,
    `        int i = posicionDescenso(n.keys, v);`,
    `        eliminarRec(n.child[i], v);`,
    `    }`,
    ``,
    `    // FIX-UNDERFLOW (si el hijo i quedó con 0 claves)`,
    `    if (!n.isLeaf()) {`,
    `        for (int i = 0; i <= n.keys.size(); i++) {`,
    `            Nodo23<T> c = n.child[i];`,
    `            if (c != null && c.keys.size() == 0) {`,
    `                corregirBajoFlujo(n, i);`,
    `            }`,
    `        }`,
    `    }`,
    `}`,
    ``,
    `/**`,
    ` * Intenta redistribuir desde hermanos; si no se puede, FUSIONA.`,
    ` * n: padre, i: índice del hijo en underflow (0..keys.size)`,
    ` */`,
    `private void corregirBajoFlujo(Nodo23<T> n, int i) {`,
    `    // hermano izquierdo`,
    `    if (i > 0 && n.child[i-1].keys.size() == 2) {`,
    `        // Rotación derecha: mover clave del padre hacia el hijo vacío`,
    `        Nodo23<T> L = n.child[i-1];`,
    `        Nodo23<T> C = n.child[i];`,
    `        // bajar clave del padre`,
    `        C.keys.add(0, n.keys.get(i-1));`,
    `        // subir última de L al padre`,
    `        n.keys.set(i-1, L.keys.remove(L.keys.size()-1));`,
    `        // mover último hijo de L a C (si no son hojas)`,
    `        if (!L.isLeaf()) {`,
    `            shiftRight(C.child, 0);`,
    `            C.child[0] = L.child[L.keys.size()+1];`,
    `            L.child[L.keys.size()+1] = null;`,
    `        }`,
    `        return;`,
    `    }`,
    `    // hermano derecho`,
    `    if (i < n.keys.size() && n.child[i+1].keys.size() == 2) {`,
    `        // Rotación izquierda: mover clave del padre hacia el hijo vacío`,
    `        Nodo23<T> R = n.child[i+1];`,
    `        Nodo23<T> C = n.child[i];`,
    `        // bajar clave del padre`,
    `        C.keys.add(n.keys.get(i));`,
    `        // subir primera de R al padre`,
    `        n.keys.set(i, R.keys.remove(0));`,
    `        // mover primer hijo de R a C (si no son hojas)`,
    `        if (!R.isLeaf()) {`,
    `            C.child[C.keys.size()] = R.child[0];`,
    `            shiftLeft(R.child, 0);`,
    `        }`,
    `        return;`,
    `    }`,
    `    // FUSIÓN: unir con hermano (preferimos fusionar con izquierdo si existe)`,
    `    if (i > 0) fusionar(n, i-1); else fusionar(n, i);`,
    `}`,
    ``,
    `/** Fusiona child[k] + clave n.keys[k] + child[k+1] en un solo nodo. */`,
    `private void fusionar(Nodo23<T> n, int k) {`,
    `    Nodo23<T> A = n.child[k];`,
    `    Nodo23<T> B = n.child[k+1];`,
    `    // bajar clave del padre al medio`,
    `    A.keys.add(n.keys.get(k));`,
    `    // mover claves de B`,
    `    for (T x : B.keys) A.keys.add(x);`,
    `    // mover hijos de B si no son hojas`,
    `    if (!B.isLeaf()) {`,
    `        int base = A.keys.size() - B.keys.size(); // o A.keys.size() - (B.keys.size())`,
    `        for (int i = 0; i <= B.keys.size(); i++) {`,
    `            A.child[base + i] = B.child[i];`,
    `        }`,
    `    }`,
    `    // eliminar clave y compactar hijos en el padre`,
    `    n.keys.remove(k);`,
    `    removeChildAt(n.child, k+1);`,
    `}`,
  ],

  search: [
    `/**`,
    ` * Busca un valor en el Árbol 1-2-3.`,
    ` * En cada nodo, se compara con sus claves ordenadas;`,
    ` * si no se encuentra, se desciende por el intervalo correspondiente.`,
    ` */`,
    `public boolean search(T valor) {`,
    `    return buscarRec(raiz, valor);`,
    `}`,
    ``,
    `private boolean buscarRec(Nodo23<T> n, T v) {`,
    `    if (n == null) return false;`,
    `    int idx = buscarEnNodo(n.keys, v);`,
    `    if (idx != -1) return true;`,
    `    if (n.isLeaf()) return false;`,
    `    int i = posicionDescenso(n.keys, v);`,
    `    return buscarRec(n.child[i], v);`,
    `}`,
  ],

  getInOrder: [
    `/**`,
    ` * InOrden para 2-3:`,
    ` *  si keys=[k0] y child=[c0,c1] -> in(c0), k0, in(c1)`,
    ` *  si keys=[k0,k1] y child=[c0,c1,c2] -> in(c0), k0, in(c1), k1, in(c2)`,
    ` */`,
    `private void inOrden(Nodo23<T> n, ListaCD<T> out) {`,
    `    if (n == null) return;`,
    `    if (n.keys.size() == 1) {`,
    `        if (!n.isLeaf()) inOrden(n.child[0], out);`,
    `        out.insertarAlFinal(n.keys.get(0));`,
    `        if (!n.isLeaf()) inOrden(n.child[1], out);`,
    `    } else {`,
    `        if (!n.isLeaf()) inOrden(n.child[0], out);`,
    `        out.insertarAlFinal(n.keys.get(0));`,
    `        if (!n.isLeaf()) inOrden(n.child[1], out);`,
    `        out.insertarAlFinal(n.keys.get(1));`,
    `        if (!n.isLeaf()) inOrden(n.child[2], out);`,
    `    }`,
    `}`,
  ],

  getPreOrder: [
    `/**`,
    ` * PreOrden para 2-3:`,
    ` *  visitar todas las claves del nodo en orden, luego sus hijos de izquierda a derecha.`,
    ` */`,
    `private void preOrden(Nodo23<T> n, ListaCD<T> out) {`,
    `    if (n == null) return;`,
    `    for (int i=0; i<n.keys.size(); i++) out.insertarAlFinal(n.keys.get(i));`,
    `    if (!n.isLeaf()) {`,
    `        for (int i=0; i<=n.keys.size(); i++) preOrden(n.child[i], out);`,
    `    }`,
    `}`,
  ],

  getPostOrder: [
    `/**`,
    ` * PostOrden para 2-3:`,
    ` *  recorrer todos los hijos y al final listar las claves del nodo en orden.`,
    ` */`,
    `private void postOrden(Nodo23<T> n, ListaCD<T> out) {`,
    `    if (n == null) return;`,
    `    if (!n.isLeaf()) {`,
    `        for (int i=0; i<=n.keys.size(); i++) postOrden(n.child[i], out);`,
    `    }`,
    `    for (int i=0; i<n.keys.size(); i++) out.insertarAlFinal(n.keys.get(i));`,
    `}`,
  ],

  getLevelOrder: [
    `/**`,
    ` * BFS para 2-3:`,
    ` *  encolar nodos; al visitar uno, emitir sus claves en orden`,
    ` *  y encolar todos sus hijos (0..keys.size()).`,
    ` */`,
    `public ListaCD<T> getLevelOrder(Nodo23<T> root) {`,
    `    ListaCD<T> out = new ListaCD<T>();`,
    `    if (root == null) return out;`,
    `    Cola<Nodo23<T>> q = new Cola<Nodo23<T>>();`,
    `    q.encolar(root);`,
    `    while (!q.esVacia()) {`,
    `        Nodo23<T> x = q.decolar();`,
    `        for (int i=0; i<x.keys.size(); i++) out.insertarAlFinal(x.keys.get(i));`,
    `        if (!x.isLeaf())`,
    `            for (int i=0; i<=x.keys.size(); i++) q.encolar(x.child[i]);`,
    `    }`,
    `    return out;`,
    `}`,
  ],

  clean: [
    `/**`,
    ` * Vacía completamente el Árbol 1-2-3.`,
    ` */`,
    `public void clean() {`,
    `    this.raiz = null;`,
    `}`,
  ],
});
