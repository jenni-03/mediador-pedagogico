import { OperationCode } from "./typesPseudoCode";

export const getListaCircularDoblementeEnlazadaCode = (): OperationCode => ({
  insertFirst: [
    "/**",
    " * Método que inserta un nuevo elemento al inicio de la lista circular doble.",
    " * @param valor Elemento a insertar.",
    " * @return Nodo inicial insertado.",
    " */",
    "public NodoD<T> insertarAlInicio(T valor) {",
    "  if (this.tamanio >= this.MAX_TAMANIO)",
    "    throw new RuntimeException(",
    '      "No fue posible insertar el nodo al inicio: Cantidad de nodos máxima alcanzada (tamaño máximo: " + this.MAX_TAMANIO + ")."',
    "    );",
    "",
    "  NodoD<T> nuevoNodo = new NodoD<>(valor);",
    "",
    "  if (this.esVacia()) {",
    "    this.cabeza = nuevoNodo;",
    "    nuevoNodo.setSiguiente(nuevoNodo);",
    "    nuevoNodo.setAnterior(nuevoNodo);",
    "  } else {",
    "    NodoD<T> ultimoNodo = this.cabeza.getAnterior();",
    "",
    "    // Conectar el nuevo nodo",
    "    nuevoNodo.setSiguiente(this.cabeza);",
    "    nuevoNodo.setAnterior(ultimoNodo);",
    "",
    "    // Actualizar los punteros",
    "    this.cabeza.setAnterior(nuevoNodo);",
    "    ultimoNodo.setSiguiente(nuevoNodo);",
    "",
    "    this.cabeza = nuevoNodo;",
    "  }",
    "",
    "  this.tamanio++;",
    "  return nuevoNodo;",
    "}",
  ],

  insertLast: [
    "/**",
    " * Método que inserta un nuevo elemento al final de la lista circular doble.",
    " * @param valor Elemento a insertar.",
    " * @return Nodo final insertado.",
    " */",
    "public NodoD<T> insertarAlFinal(T valor) {",
    "  if (this.tamanio >= this.MAX_TAMANIO)",
    "    throw new RuntimeException(",
    '      "No fue posible insertar el nodo al final: Cantidad de nodos máxima alcanzada (tamaño máximo: " + this.MAX_TAMANIO + ")."',
    "    );",
    "",
    "  NodoD<T> nuevoNodo = new NodoD<>(valor);",
    "",
    "  if (this.esVacia()) {",
    "    this.cabeza = nuevoNodo;",
    "    nuevoNodo.setSiguiente(nuevoNodo);",
    "    nuevoNodo.setAnterior(nuevoNodo);",
    "  } else {",
    "    NodoD<T> ultimoNodo = this.cabeza.getAnterior();",
    "",
    "    // Actualizar los punteros",
    "    ultimoNodo.setSiguiente(nuevoNodo);",
    "    this.cabeza.setAnterior(nuevoNodo);",
    "",
    "    // Conectar el nuevo nodo",
    "    nuevoNodo.setSiguiente(this.cabeza);",
    "    nuevoNodo.setAnterior(ultimoNodo);",
    "  }",
    "",
    "  this.tamanio++;",
    "  return nuevoNodo;",
    "}",
  ],

  insertAt: [
    "/**",
    " * Método que inserta un nuevo elemento en una posición especifica de la lista circular doble.",
    " * @param valor Elemento a insertar.",
    " * @param posicion Posición en la que se desea insertar el elemento.",
    " * @return Nodo insertado en la posición especificada.",
    " */",
    "public NodoD<T> insertarEnPosicion(T valor, int posicion) {",
    "  if (posicion < 0 || posicion > this.tamanio) {",
    "    throw new RuntimeException(",
    '      "No fue posible insertar el nodo en la posición especificada: La posición " + posicion + " no existe dentro de la Lista Doble."',
    "    );",
    "  }",
    "",
    "  if (this.tamanio >= this.MAX_TAMANIO)",
    "    throw new RuntimeException(",
    '      "No fue posible insertar el nodo en la posición especificada: Cantidad de nodos máxima alcanzada (tamaño máximo: " + this.MAX_TAMANIO + ")."',
    "    );",
    "",
    "  if (posicion == 0) {",
    "    return this.insertarAlInicio(valor);",
    "  }",
    "",
    "  if (posicion == this.tamanio) {",
    "    return this.insertarAlFinal(valor);",
    "  }",
    "",
    "  NodoD<T> nuevoNodo = new NodoD<>(valor);",
    "  NodoD<T> nodoAnt = this.getPos(posicion - 1);",
    "",
    "  // Conectar el nuevo nodo a la lista",
    "  nuevoNodo.setSiguiente(nodoAnt.getSiguiente());",
    "  nuevoNodo.setAnterior(nodoAnt);",
    "",
    "  // Reorganizar los punteros",
    "  nodoAnt.getSiguiente().setAnterior(nuevoNodo);",
    "  nodoAnt.setSiguiente(nuevoNodo);",
    "",
    "  this.tamanio++;",
    "  return nuevoNodo;",
    "}",
  ],

  removeFirst: [
    "/**",
    " * Método que elimina el primer nodo de la lista circular doble.",
    " * @return Nodo inicial eliminado.",
    " */",
    "public NodoD<T> eliminarAlInicio() {",
    "  if (this.esVacia())",
    "    throw new RuntimeException(",
    '      "No fue posible eliminar el nodo inicial: La lista se encuentra vacía (tamaño actual: 0)."',
    "    );",
    "",
    "  NodoD<T> nodoEliminado = this.cabeza;",
    "",
    "  if (this.cabeza.getSiguiente() == this.cabeza) {",
    "    this.cabeza = null;",
    "  } else {",
    "    NodoD<T> newHead = this.cabeza.getSiguiente();",
    "    NodoD<T> tail = this.cabeza.getAnterior();",
    "",
    "    // Desconectar el nodo de la lista",
    "    nodoEliminado.setSiguiente(null);",
    "    nodoEliminado.setAnterior(null);",
    "",
    "    // Reorganizar los punteros",
    "    tail.setSiguiente(newHead);",
    "    newHead.setAnterior(tail);",
    "",
    "    this.cabeza = newHead;",
    "  }",
    "",
    "  this.tamanio--;",
    "  return nodoEliminado;",
    "}",
  ],

  removeLast: [
    "/**",
    " * Método que elimina el último nodo de la lista circular doble.",
    " * @return Nodo final eliminado.",
    " */",
    "public NodoD<T> eliminarAlFinal() {",
    "  if (this.esVacia())",
    '    throw new RuntimeException("No fue posible eliminar el nodo final: La lista se encuentra vacía (tamaño actual: 0).");',
    "",
    "  NodoD<T> ultimo = this.cabeza.getAnterior();",
    "",
    "  if (this.cabeza == ultimo) {",
    "    this.cabeza = null;",
    "  } else {",
    "    NodoD<T> nuevoUltimo = ultimo.getAnterior();",
    "",
    "    // Reorganizar los punteros",
    "    nuevoUltimo.setSiguiente(this.cabeza);",
    "    this.cabeza.setAnterior(nuevoUltimo);",
    "",
    "    // Desconectar el nodo de la lista",
    "    ultimo.setSiguiente(null);",
    "    ultimo.setAnterior(null);",
    "  }",
    "",
    "  this.tamanio--;",
    "  return ultimo;",
    "}",
  ],

  removeAt: [
    "/**",
    " * Método que elimina un nodo en una posición especifica de la lista circular doble.",
    " * @param posicion Posición del nodo a eliminar.",
    " * @return Nodo eliminado.",
    " */",
    "public NodoD<T> eliminarEnPosicion(int posicion) {",
    "  if (this.esVacia())",
    '    throw new RuntimeException("No fue posible eliminar el nodo en la posición especificada: La lista se encuentra vacía (tamaño actual: 0).");',
    "",
    "  if (posicion < 0 || posicion >= this.tamanio) {",
    '    throw new RuntimeException("No fue posible eliminar el nodo en la posición especificada: La posición " + posicion + " no existe dentro de la Lista.");',
    "  }",
    "",
    "  if (posicion == 0) {",
    "    return this.eliminarAlInicio();",
    "  }",
    "",
    "  if (posicion == this.tamanio - 1) {",
    "    return this.eliminarAlFinal();",
    "  }",
    "",
    "  NodoD<T> nodoEliminado = this.getPos(posicion);",
    "",
    "  nodoEliminado.getAnterior().setSiguiente(nodoEliminado.getSiguiente());",
    "  nodoEliminado.getSiguiente().setAnterior(nodoEliminado.getAnterior());",
    "",
    "  this.tamanio--;",
    "  return nodoEliminado;",
    "}",
  ],

  search: [
    "/**",
    " * Método que busca un nodo en la lista circular doble.",
    " * @param valor Valor a buscar.",
    " * @return true si se encuentra el nodo, false en caso contrario.",
    " */",
    "public boolean buscar(T valor) {",
    "  if (this.esVacia()) return false;",
    "",
    "  NodoD<T> nodoActual = this.cabeza;",
    "  do {",
    "    if (this.equals(nodoActual.getValor(), valor)) return true;",
    "    nodoActual = nodoActual.getSiguiente();",
    "  } while (nodoActual != this.cabeza);",
    "",
    "  return false;",
    "}",
  ],

  clean: [
    "/**",
    " * Método que vacía la lista circular doble.",
    " * post: La lista quedó vacía.",
    " */",
    "public void vaciar() {",
    "  this.cabeza = null;",
    "  this.tamanio = 0;",
    "}",
  ],
});
