import { OperationCode } from "./typesPseudoCode";

export const getListaCircularSimplementeEnlazadaCode = (): OperationCode => ({
  insertFirst: [
    `/**
 * Método que inserta un nuevo elemento al inicio de la lista circular simple.
 * @param valor Elemento a insertar.
 * @return Nodo inicial insertado.
 */`,
    `public NodoS<T> insertarAlInicio(T {0}) {`,
    `    if ({1} >= this.MAX_TAMANIO)`,
    `        throw new RuntimeException("No fue posible insertar el nodo al inicio: Cantidad de nodos máxima alcanzada (tamaño máximo: " + this.MAX_TAMANIO + ").");`,
    ``,
    `    NodoS<T> nuevoNodo = new NodoS<>({0});`,
    ``,
    `    if (this.esVacia()) {`,
    `        this.cabeza = nuevoNodo;`,
    `        this.cola = nuevoNodo;`,
    `        nuevoNodo.setSiguiente(nuevoNodo);`,
    `    } else {`,
    `        nuevoNodo.setSiguiente(this.cabeza);`,
    `        this.cola.setSiguiente(nuevoNodo);`,
    `        this.cabeza = nuevoNodo;`,
    `    }`,
    ``,
    `    {1}++;`,
    `    return nuevoNodo;`,
    `}`,
  ],

  insertLast: [
    `/**
 * Método que inserta un nuevo elemento al final de la lista circular simple.
 * @param valor Elemento a insertar.
 * @return Nodo final insertado.
 */`,
    `public NodoS<T> insertarAlFinal(T {0}) {`,
    `    if ({1} >= this.MAX_TAMANIO)`,
    `        throw new RuntimeException("No fue posible insertar el nodo al final: Cantidad de nodos máxima alcanzada (tamaño máximo: " + this.MAX_TAMANIO + ").");`,
    ``,
    `    NodoS<T> nuevoNodo = new NodoS<>({0});`,
    ``,
    `    if (this.esVacia()) {`,
    `        this.cabeza = nuevoNodo;`,
    `        this.cola = nuevoNodo;`,
    `        nuevoNodo.setSiguiente(nuevoNodo);`,
    `    } else {`,
    `        this.cola.setSiguiente(nuevoNodo);`,
    `        nuevoNodo.setSiguiente(this.cabeza);`,
    `        this.cola = nuevoNodo;`,
    `    }`,
    ``,
    `    {1}++;`,
    `    return nuevoNodo;`,
    `}`,
  ],

  insertAt: [
    `/**
 * Método que inserta un nuevo elemento en una posición específica de la lista circular simple.
 * @param valor Elemento a insertar.
 * @param posicion Posición en la que se desea insertar el elemento.
 * @return Nodo insertado en la posición especificada.
 */`,
    `public NodoS<T> insertarEnPosicion(T {0}, int {1}) {`,
    `    if ({1} < 0 || {1} > {2})`,
    `        throw new RuntimeException("No fue posible insertar el nodo en la posición especificada: La posición " + {1} + " no existe dentro de la Lista Simple.");`,
    ``,
    `    if ({2} >= this.MAX_TAMANIO)`,
    `        throw new RuntimeException("No fue posible insertar el nodo en la posición especificada: Cantidad de nodos máxima alcanzada (tamaño máximo: " + this.MAX_TAMANIO + ").");`,
    ``,
    `    if ({1} == 0)`,
    `        return this.insertarAlInicio({0});`,
    ``,
    `    if ({1} == {2})`,
    `        return this.insertarAlFinal({0});`,
    ``,
    `    NodoS<T> nuevoNodo = new NodoS<>({0});`,
    `    NodoS<T> nodoAnt = this.getPos({1} - 1);`,
    ``,
    `    nuevoNodo.setSiguiente(nodoAnt.getSiguiente());`,
    `    nodoAnt.setSiguiente(nuevoNodo);`,
    ``,
    `    {2}++;`,
    `    return nuevoNodo;`,
    `}`,
  ],

  removeFirst: [
    `/**
 * Método que elimina el primer nodo de la lista circular simple.
 * @return Nodo inicial eliminado.
 */`,
    `public NodoS<T> eliminarAlInicio() {`,
    `    if (this.esVacia())`,
    `        throw new RuntimeException("No fue posible eliminar el nodo inicial: La lista se encuentra vacía (tamaño actual: 0).");`,
    ``,
    `    NodoS<T> nodoEliminado = this.cabeza;`,
    ``,
    `    if (this.cabeza == this.cola) {`,
    `        this.cabeza = null;`,
    `        this.cola = null;`,
    `    } else {`,
    `        this.cabeza = this.cabeza.getSiguiente();`,
    `        this.cola.setSiguiente(this.cabeza);`,
    `    }`,
    ``,
    `    {0}--;`,
    `    return nodoEliminado;`,
    `}`,
  ],
  removeLast: [
    "/**",
    " * Método que elimina el último nodo de la lista circular simple.",
    " * @return Nodo final eliminado.",
    " */",
    "public NodoS<T> eliminarAlFinal() {",
    "  if (this.esVacia())",
    "    throw new RuntimeException(",
    '      "No fue posible eliminar el nodo final: La lista se encuentra vacía (tamaño actual: 0)."',
    "    );",
    "",
    "  NodoS<T> nodoEliminado;",
    "",
    "  if (this.cabeza == this.cola) {",
    "    nodoEliminado = this.cabeza;",
    "    this.cabeza = null;",
    "    this.cola = null;",
    "  } else {",
    "    nodoEliminado = this.cola;",
    "    NodoS<T> nodoAnt = this.getPos({0} - 2);",
    "    nodoAnt.setSiguiente(this.cabeza);",
    "    this.cola = nodoAnt;",
    "  }",
    "",
    "  {0}--;",
    "  return nodoEliminado;",
    "}",
  ],

  removeAt: [
    "/**",
    " * Método que elimina un nodo en una posición especifica de la lista circular simple.",
    " * @param posicion Posición del nodo a eliminar.",
    " * @return Nodo eliminado.",
    " */",
    "public NodoS<T> eliminarEnPosicion(int {0}) {",
    "  if (this.esVacia())",
    "    throw new RuntimeException(",
    '      "No fue posible eliminar el nodo en la posición especificada: La lista se encuentra vacía (tamaño actual: 0)."',
    "    );",
    "",
    "  if ({0} < 0 || {0} >= {1}) {",
    "    throw new RuntimeException(",
    '      "No fue posible eliminar el nodo en la posición especificada: La posición " + {0} + " no existe dentro de la Lista Simple."',
    "    );",
    "  }",
    "",
    "  if ({0} == 0) {",
    "    return this.eliminarAlInicio();",
    "  }",
    "",
    "  if ({0} == {1} - 1) {",
    "    return this.eliminarAlFinal();",
    "  }",
    "",
    "  NodoS<T> nodoAnt = this.getPos({0} - 1);",
    "  NodoS<T> nodoEliminado = nodoAnt.getSiguiente();",
    "",
    "  nodoAnt.setSiguiente(nodoEliminado.getSiguiente());",
    "",
    "  {1}--;",
    "  return nodoEliminado;",
    "}",
  ],

  search: [
    "/**",
    " * Método que busca un nodo en la lista circular simple.",
    " * @param valor Valor a buscar.",
    " * @return true si se encuentra el nodo, false en caso contrario.",
    " */",
    "public boolean buscar(T {0}) {",
    "  if (this.esVacia()) return false;",
    "",
    "  NodoS<T> nodoActual = this.cabeza;",
    "",
    "  do {",
    "    if (this.equals(nodoActual.getValor(), {0})) return true;",
    "    nodoActual = nodoActual.getSiguiente();",
    "  } while (nodoActual != this.cabeza);",
    "",
    "  return false;",
    "}",
  ],

  clean: [
    "/**",
    " * Método que permite eliminar todos los nodos de la lista circular simple.",
    " * post: Se eliminaron todos los nodos en la lista.",
    " */",
    "public void vaciar() {",
    "  this.cabeza = null;",
    "  this.cola = null;",
    "  this.tamanio = 0;",
    "}",
  ],
});
