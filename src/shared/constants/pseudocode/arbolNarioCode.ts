import { OperationCode } from "./typesPseudoCode";

export const getArbolNarioCode = (): OperationCode => ({
  createRoot: [
    `/** Crea la raíz del árbol N-ario. */`,
    `public void createRoot(T {0}) {`,
    `    if (raiz != null) throw new RuntimeException("La raíz ya existe");`,
    `    raiz = new NodoN({0});`,
    `    // hijos = lista vacía`,
    `}`,
  ],

  insertChild: [
    `/**`,
    ` * Inserta un nuevo hijo bajo un padre dado (por id).`,
    ` * Si 'index' se omite, agrega al final; si se especifica, inserta en esa posición.`,
    ` */`,
    `public void insertChild(String {0}, T {1}, Integer index = null) {`,
    `    if (raiz == null) throw new RuntimeException("Árbol vacío: primero crea la raíz");`,
    `    NodoN padre = buscarPorIdBFS(raiz, {0});`,
    `    if (padre == null) throw new RuntimeException("Padre no existe");`,
    `    NodoN nuevo = new NodoN({1});`,
    `    if (index == null) padre.hijos.agregar(nuevo);`,
    `    else padre.hijos.insertar(index, nuevo);`,
    `    nuevo.padre = padre;`,
    `}`,
  ],

  deleteNode: [
    `/**`,
    ` * Elimina un nodo (y todo su subárbol) por id.`,
    ` * Si el nodo es la raíz, el árbol queda vacío.`,
    ` */`,
    `public void deleteNode(String {0}) {`,
    `    if (raiz == null) return;`,
    `    NodoN objetivo = buscarPorIdBFS(raiz, {0});`,
    `    if (objetivo == null) throw new RuntimeException("No existe el nodo con id: {0});`,
    `    if (objetivo == raiz) {`,
    `        raiz = null;`,
    `        return;`,
    `    }`,
    `    NodoN p = objetivo.padre;`,
    `    int k = p.hijos.indiceDe(objetivo);`,
    `    p.hijos.eliminarEn(k);`,
    `}`,
  ],

  moveNode: [
    `/**`,
    ` * Mueve un subárbol (id) para que cuelgue de 'nuevoPadreId'.`,
    ` * Usa 'index' opcional para indicar la posición del nuevo hijo.`,
    ` * No permite mover dentro de su propio subárbol (evita ciclos).`,
    ` */`,
    `public void moveNode(String {0}, String {1}, Integer index = null) {`,
    `    if ({0}.equals({1})) throw new RuntimeException("Movimiento inválido");`,
    `    NodoN x = buscarPorIdBFS(raiz, {0});`,
    `    NodoN p = buscarPorIdBFS(raiz, {1});`,
    `    if (x == null || p == null) throw new RuntimeException("Nodo no encontrado");`,
    `    if (esDescendiente(p, x)) throw new RuntimeException("Crearía un ciclo");`,
    `    if (x == raiz) throw new RuntimeException("No se puede mover la raíz");`,
    `    // Desvincular de su padre actual`,
    `    NodoN actual = x.padre;`,
    `    int i = actual.hijos.indiceDe(x);`,
    `    actual.hijos.eliminarEn(i);`,
    `    // Vincular en el nuevo padre`,
    `    if (index == null) p.hijos.agregar(x);`,
    `    else p.hijos.insertar(index, x);`,
    `    x.padre = p;`,
    `}`,
  ],

  updateValue: [
    `/** Actualiza el valor almacenado en un nodo por id. */`,
    `public void updateValue(String {0}, T {1}) {`,
    `    NodoN n = buscarPorIdBFS(raiz, {0});`,
    `    if (n == null) throw new RuntimeException("No existe el nodo con id: {0}}");`,
    `    n.info = {1};`,
    `}`,
  ],

  search: [
    `/**`,
    ` * Busca el primer nodo cuyo valor coincida (BFS).`,
    ` * Retorna true si se encuentra; además permite resaltar el camino.`,
    ` */`,
    `public boolean search(T {0}) {`,
    `    if (raiz == null) return false;`,
    `    Cola<NodoN> q = new Cola<>();`,
    `    q.encolar(raiz);`,
    `    while (!q.esVacia()) {`,
    `        NodoN u = q.decolar();`,
    `        if (u.info.equals({0})) return true;`,
    `        for (NodoN h : u.hijos) q.encolar(h);`,
    `    }`,
    `    return false;`,
    `}`,
  ],

  getPreOrder: [
    `/**`,
    ` * Obtiene el recorrido en preorden (nodo → hijos).`,
    ` */`,
    `public void getPreOrder(NodoN n, Lista<T> resultado) {`,
    `    if (n == null) return;`,
    `    resultado.agregar(n.info);`,
    `    for (NodoN h : n.hijos) getPreOrder(h, resultado);`,
    `}`,
  ],

  getPostOrder: [
    `/**`,
    ` * Obtiene el recorrido en postorden (hijos → nodo).`,
    ` */`,
    `public void getPostOrder(NodoN n, Lista<T> resultado) {`,
    `    if (n == null) return;`,
    `    for (NodoN h : n.hijos) getPostOrder(h, resultado);`,
    `    resultado.agregar(n.info);`,
    `}`,
  ],

  getLevelOrder: [
    `/**`,
    ` * Obtiene el recorrido por niveles (BFS).`,
    ` */`,
    `public void getLevelOrder(Lista<T> resultado) {`,
    `    if (raiz == null) return;`,
    `    Cola<NodoN> q = new Cola<>();`,
    `    q.encolar(raiz);`,
    `    while (!q.esVacia()) {`,
    `        NodoN u = q.decolar();`,
    `        resultado.agregar(u.info);`,
    `        for (NodoN h : u.hijos) q.encolar(h);`,
    `    }`,
    `}`,
  ],

  clean: [
    `/** Vacía por completo el árbol N-ario. */`,
    `public void clean() {`,
    `    raiz = null;`,
    `}`,
  ],
});
