// pseudocode/arbol_b/getArbolBCode.ts
import { OperationCode } from "./typesPseudoCode";

/**
 * Pseudocódigo de Árbol B (grado mínimo t ≥ 2)
 * BTreeNode:
 *   keys: lista ordenada de T (t-1 .. 2t-1 claves)
 *   child: arreglo de hijos (0 .. 2t)   // child.length = keys.length + 1 cuando no es hoja
 *   leaf: boolean
 *   t: grado mínimo
 *
 * Propiedades:
 *  - Toda hoja al mismo nivel.
 *  - Todo nodo (excepto raíz) tiene al menos t-1 claves y como máximo 2t-1.
 *  - La raíz tiene entre 1 y 2t-1 claves (o 0 si árbol vacío).
 */
export const getArbolBCode = (): OperationCode => ({

  insert: [
    `/**`,
    ` * Inserta un valor en el Árbol B.`,
    ` * Si la raíz está llena, se crea una nueva raíz y se hace split.`,
    ` */`,
    `public void insert(T k) {`,
    `    if (root == null) root = new BTreeNode(t, true);`,
    `    if (root.keys.size() == 2*t - 1) {`,
    `        BTreeNode s = new BTreeNode(t, false);`,
    `        s.child[0] = root;`,
    `        splitChild(s, 0, root);`,
    `        int i = (k.compareTo(s.keys.get(0)) > 0) ? 1 : 0;`,
    `        insertNonFull(s.child[i], k);`,
    `        root = s;`,
    `    } else {`,
    `        insertNonFull(root, k);`,
    `    }`,
    `}`,
    ``,
    `/** Inserta k en un nodo que NO está lleno. */`,
    `private void insertNonFull(BTreeNode x, T k) {`,
    `    int i = x.keys.size() - 1;`,
    `    if (x.leaf) {`,
    `        // Insertar en la posición ordenada`,
    `        x.keys.add(null); // espacio`,
    `        while (i >= 0 && k.compareTo(x.keys.get(i)) < 0) {`,
    `            x.keys.set(i+1, x.keys.get(i));`,
    `            i--;`,
    `        }`,
    `        x.keys.set(i+1, k);`,
    `    } else {`,
    `        // Encontrar hijo de descenso`,
    `        while (i >= 0 && k.compareTo(x.keys.get(i)) < 0) i--;`,
    `        i++;`,
    `        if (x.child[i].keys.size() == 2*t - 1) {`,
    `            splitChild(x, i, x.child[i]);`,
    `            if (k.compareTo(x.keys.get(i)) > 0) i++;`,
    `        }`,
    `        insertNonFull(x.child[i], k);`,
    `    }`,
    `}`,
    ``,
    `/** Divide el hijo y de x en dos nodos con t-1 claves y promueve la clave media. */`,
    `private void splitChild(BTreeNode x, int i, BTreeNode y) {`,
    `    BTreeNode z = new BTreeNode(t, y.leaf);`,
    `    // z recibe las últimas t-1 claves de y`,
    `    for (int j = 0; j < t-1; j++) z.keys.add(y.keys.remove(t));`,
    `    if (!y.leaf) {`,
    `        for (int j = 0; j < t; j++) z.child[j] = y.child[t + j];`,
    `        for (int j = 0; j < t; j++) y.child[t + j] = null;`,
    `    }`,
    `    // Insertar nueva clave media en x`,
    `    x.keys.add(i, y.keys.remove(t-1));`,
    `    // Reacomodar hijos de x`,
    `    shiftRight(x.child, i+1);`,
    `    x.child[i+1] = z;`,
    `}`,
  ],

  delete: [
    `/**`,
    ` * Elimina una clave k del Árbol B (CLRS-style).`,
    ` */`,
    `public void delete(T k) {`,
    `    if (root == null) return;`,
    `    deleteFromNode(root, k);`,
    `    // Ajuste de raíz: si quedó sin claves y tiene hijo, desciende`,
    `    if (root.keys.size() == 0 && !root.leaf) root = root.child[0];`,
    `    if (root.keys.size() == 0 && root.leaf) root = null;`,
    `}`,
    ``,
    `/** Elimina k del subárbol enraizado en x. */`,
    `private void deleteFromNode(BTreeNode x, T k) {`,
    `    int idx = indexOf(x.keys, k); // -1 si no está`,
    `    if (idx != -1) {`,
    `        if (x.leaf) {`,
    `            x.keys.remove(idx);`,
    `        } else {`,
    `            // Reemplazar por predecesor o sucesor y borrar abajo`,
    `            BTreeNode y = x.child[idx];`,
    `            BTreeNode z = x.child[idx+1];`,
    `            if (y.keys.size() >= t) {`,
    `                T pred = getPredecessor(y);`,
    `                x.keys.set(idx, pred);`,
    `                deleteFromNode(y, pred);`,
    `            } else if (z.keys.size() >= t) {`,
    `                T succ = getSuccessor(z);`,
    `                x.keys.set(idx, succ);`,
    `                deleteFromNode(z, succ);`,
    `            } else {`,
    `                merge(x, idx); // fusiona y + k + z en y`,
    `                deleteFromNode(y, k);`,
    `            }`,
    `        }`,
    `    } else {`,
    `        if (x.leaf) return;`,
    `        int i = childIndexToDescend(x.keys, k);`,
    `        // Asegurar que el hijo tiene >= t claves antes de descender`,
    `        if (x.child[i].keys.size() < t) fill(x, i);`,
    `        // Tras fill, puede que i cambie si fusionamos con el derecho`,
    `        if (i > x.keys.size()) i = x.keys.size();`,
    `        deleteFromNode(x.child[i], k);`,
    `    }`,
    `}`,
    ``,
    `/** Si child[i] tiene t-1 claves, lo arregla tomando de hermanos o fusionando. */`,
    `private void fill(BTreeNode x, int i) {`,
    `    if (i > 0 && x.child[i-1].keys.size() >= t)`,
    `        borrowFromPrev(x, i);`,
    `    else if (i < x.keys.size() && x.child[i+1].keys.size() >= t)`,
    `        borrowFromNext(x, i);`,
    `    else {`,
    `        if (i < x.keys.size()) merge(x, i); else merge(x, i-1);`,
    `    }`,
    `}`,
    ``,
    `private void borrowFromPrev(BTreeNode x, int i) {`,
    `    BTreeNode c = x.child[i];`,
    `    BTreeNode s = x.child[i-1];`,
    `    // Desplazar claves/hijos en c hacia la derecha`,
    `    shiftRight(c.child, 0);`,
    `    c.keys.add(0, x.keys.get(i-1));`,
    `    if (!c.leaf) c.child[0] = s.child[s.keys.size()+1];`,
    `    x.keys.set(i-1, s.keys.remove(s.keys.size()-1));`,
    `}`,
    ``,
    `private void borrowFromNext(BTreeNode x, int i) {`,
    `    BTreeNode c = x.child[i];`,
    `    BTreeNode s = x.child[i+1];`,
    `    c.keys.add(x.keys.get(i));`,
    `    if (!c.leaf) c.child[c.keys.size()] = s.child[0];`,
    `    x.keys.set(i, s.keys.remove(0));`,
    `    shiftLeft(s.child, 0);`,
    `}`,
    ``,
    `/** Fusiona child[k] + x.keys[k] + child[k+1] en child[k]. */`,
    `private void merge(BTreeNode x, int k) {`,
    `    BTreeNode y = x.child[k];`,
    `    BTreeNode z = x.child[k+1];`,
    `    y.keys.add(x.keys.remove(k));`,
    `    // mover claves de z`,
    `    for (T val : z.keys) y.keys.add(val);`,
    `    if (!z.leaf) {`,
    `        int base = y.keys.size() - z.keys.size();`,
    `        for (int i=0; i<=z.keys.size(); i++) y.child[base + i] = z.child[i];`,
    `    }`,
    `    removeChildAt(x.child, k+1);`,
    `}`,
    ``,
    `private T getPredecessor(BTreeNode x) {`,
    `    while (!x.leaf) x = x.child[x.keys.size()];`,
    `    return x.keys.get(x.keys.size()-1);`,
    `}`,
    ``,
    `private T getSuccessor(BTreeNode x) {`,
    `    while (!x.leaf) x = x.child[0];`,
    `    return x.keys.get(0);`,
    `}`,
  ],

  search: [
    `/**`,
    ` * Busca un valor en el Árbol B.`,
    ` */`,
    `public boolean search(T k) {`,
    `    return searchRec(root, k);`,
    `}`,
    ``,
    `private boolean searchRec(BTreeNode x, T k) {`,
    `    if (x == null) return false;`,
    `    int i = lowerBound(x.keys, k); // primer índice >= k`,
    `    if (i < x.keys.size() && x.keys.get(i).equals(k)) return true;`,
    `    if (x.leaf) return false;`,
    `    return searchRec(x.child[i], k);`,
    `}`,
  ],

  getInOrder: [
    `/**`,
    ` * InOrden generalizado:`,
    ` *  Para m = keys.size() claves ->`,
    ` *  child[0], k0, child[1], k1, ..., child[m],`,
    ` */`,
    `private void inOrder(BTreeNode n, ListaCD<T> out) {`,
    `    if (n == null) return;`,
    `    for (int i=0; i<n.keys.size(); i++) {`,
    `        if (!n.leaf) inOrder(n.child[i], out);`,
    `        out.insertarAlFinal(n.keys.get(i));`,
    `    }`,
    `    if (!n.leaf) inOrder(n.child[n.keys.size()], out);`,
    `}`,
  ],

  getPreOrder: [
    `/**`,
    ` * PreOrden: primero todas las claves del nodo, luego hijos de izq→der.`,
    ` */`,
    `private void preOrder(BTreeNode n, ListaCD<T> out) {`,
    `    if (n == null) return;`,
    `    for (int i=0; i<n.keys.size(); i++) out.insertarAlFinal(n.keys.get(i));`,
    `    if (!n.leaf)`,
    `        for (int i=0; i<=n.keys.size(); i++) preOrder(n.child[i], out);`,
    `}`,
  ],

  getPostOrder: [
    `/**`,
    ` * PostOrden: visitar todos los hijos y luego las claves del nodo.`,
    ` */`,
    `private void postOrder(BTreeNode n, ListaCD<T> out) {`,
    `    if (n == null) return;`,
    `    if (!n.leaf)`,
    `        for (int i=0; i<=n.keys.size(); i++) postOrder(n.child[i], out);`,
    `    for (int i=0; i<n.keys.size(); i++) out.insertarAlFinal(n.keys.get(i));`,
    `}`,
  ],

  getLevelOrder: [
    `/**`,
    ` * BFS: encolar nodos; al visitar uno, emitir sus claves y encolar sus hijos.`,
    ` */`,
    `public ListaCD<T> getLevelOrder(BTreeNode root) {`,
    `    ListaCD<T> out = new ListaCD<T>();`,
    `    if (root == null) return out;`,
    `    Cola<BTreeNode> q = new Cola<BTreeNode>();`,
    `    q.encolar(root);`,
    `    while (!q.esVacia()) {`,
    `        BTreeNode x = q.decolar();`,
    `        for (int i=0; i<x.keys.size(); i++) out.insertarAlFinal(x.keys.get(i));`,
    `        if (!x.leaf)`,
    `            for (int i=0; i<=x.keys.size(); i++) q.encolar(x.child[i]);`,
    `    }`,
    `    return out;`,
    `}`,
  ],

  clean: [
    `/**`,
    ` * Vacía completamente el Árbol B.`,
    ` */`,
    `public void clean() {`,
    `    this.root = null;`,
    `}`,
  ],
});
