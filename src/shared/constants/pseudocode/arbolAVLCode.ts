// pseudocode/avl/getArbolAVLCode.ts
import { OperationCode } from "./typesPseudoCode";

export const getArbolAVLCode = (): OperationCode => ({
  insert: [
    `/**`,
    ` * Inserta un valor en el AVL y rebalancea si es necesario.`,
    ` * post: El árbol mantiene |bf| <= 1 tras la inserción.`,
    ` */`,
    `public void insert(T valor) {`,
    `    this.raiz = insertarAVL(this.raiz, valor);`,
    `}`,
    ``,
    `private NodoAVL<T> insertarAVL(NodoAVL<T> nodo, T valor) {`,
    `    if (nodo == null) return new NodoAVL<T>(valor);`,
    ``,
    `    int cmp = valor.compareTo(nodo.getInfo());`,
    `    if (cmp < 0) {`,
    `        nodo.setIzq(insertarAVL(nodo.getIzq(), valor));`,
    `    } else if (cmp > 0) {`,
    `        nodo.setDer(insertarAVL(nodo.getDer(), valor));`,
    `    } else {`,
    `        // Duplicado: no insertamos de nuevo`,
    `        return nodo;`,
    `    }`,
    ``,
    `    actualizarAltura(nodo);`,
    `    int bf = factorBalance(nodo);`,
    ``,
    `    // Caso LL`,
    `    if (bf > 1 && valor.compareTo(nodo.getIzq().getInfo()) < 0)`,
    `        return rotacionDerecha(nodo);`,
    `    // Caso RR`,
    `    if (bf < -1 && valor.compareTo(nodo.getDer().getInfo()) > 0)`,
    `        return rotacionIzquierda(nodo);`,
    `    // Caso LR`,
    `    if (bf > 1 && valor.compareTo(nodo.getIzq().getInfo()) > 0) {`,
    `        nodo.setIzq(rotacionIzquierda(nodo.getIzq()));`,
    `        return rotacionDerecha(nodo);`,
    `    }`,
    `    // Caso RL`,
    `    if (bf < -1 && valor.compareTo(nodo.getDer().getInfo()) < 0) {`,
    `        nodo.setDer(rotacionDerecha(nodo.getDer()));`,
    `        return rotacionIzquierda(nodo);`,
    `    }`,
    ``,
    `    return nodo;`,
    `}`,
  ],

  delete: [
     `/**`,
    ` * Elimina un valor del AVL y rebalancea si es necesario.`,
    ` * post: El árbol mantiene |bf| <= 1 tras la eliminación.`,
    ` */`,
    `public void delete(T valor) {`,
    `    this.raiz = eliminarAVL(this.raiz, valor);`,
    `}`,
    ``,
    `private NodoAVL<T> eliminarAVL(NodoAVL<T> nodo, T valor) {`,
    `    if (nodo == null) return null;`,
    ``,
    `    int cmp = valor.compareTo(nodo.getInfo());`,
    `    if (cmp < 0) {`,
    `        nodo.setIzq(eliminarAVL(nodo.getIzq(), valor));`,
    `    } else if (cmp > 0) {`,
    `        nodo.setDer(eliminarAVL(nodo.getDer(), valor));`,
    `    } else {`,
    `        // Nodo encontrado`,
    `        if (nodo.getIzq() == null || nodo.getDer() == null) {`,
    `            NodoAVL<T> temp = (nodo.getIzq() != null) ? nodo.getIzq() : nodo.getDer();`,
    `            nodo = temp; // puede quedar null si era hoja`,
    `        } else {`,
    `            // Sucesor inOrden (mínimo del subárbol derecho)`,
    `            NodoAVL<T> succ = minValor(nodo.getDer());`,
    `            nodo.setInfo(succ.getInfo());`,
    `            nodo.setDer(eliminarAVL(nodo.getDer(), succ.getInfo()));`,
    `        }`,
    `    }`,
    ``,
    `    if (nodo == null) return null;`,
    ``,
    `    actualizarAltura(nodo);`,
    `    int bf = factorBalance(nodo);`,
    ``,
    `    // Rebalanceos post-eliminación`,
    `    // LL`,
    `    if (bf > 1 && factorBalance(nodo.getIzq()) >= 0)`,
    `        return rotacionDerecha(nodo);`,
    `    // LR`,
    `    if (bf > 1 && factorBalance(nodo.getIzq()) < 0) {`,
    `        nodo.setIzq(rotacionIzquierda(nodo.getIzq()));`,
    `        return rotacionDerecha(nodo);`,
    `    }`,
    `    // RR`,
    `    if (bf < -1 && factorBalance(nodo.getDer()) <= 0)`,
    `        return rotacionIzquierda(nodo);`,
    `    // RL`,
    `    if (bf < -1 && factorBalance(nodo.getDer()) > 0) {`,
    `        nodo.setDer(rotacionDerecha(nodo.getDer()));`,
    `        return rotacionIzquierda(nodo);`,
    `    }`,
    ``,
    `    return nodo;`,
    `}`,
    ``,
    `private NodoAVL<T> minValor(NodoAVL<T> n) {`,
    `    while (n.getIzq() != null) n = n.getIzq();`,
    `    return n;`,
    `}`,
  ],

  search: [
    `/**`,
    ` * Busca un valor en el AVL (propiedad BST).`,
    ` * @return true si existe, false en caso contrario.`,
    ` */`,
    `public boolean search(T valor) {`,
    `    return buscar(this.raiz, valor);`,
    `}`,
    ``,
    `private boolean buscar(NodoAVL<T> root, T valor) {`,
    `    if (root == null) return false;`,
    `    int cmp = valor.compareTo(root.getInfo());`,
    `    if (cmp == 0) return true;`,
    `    if (cmp < 0) return buscar(root.getIzq(), valor);`,
    `    return buscar(root.getDer(), valor);`,
    `}`,
  ],

  getInOrder: [
    `/**`,
    ` * Recorrido inOrden: izquierda → nodo → derecha.`,
    ` */`,
    `private void inOrden(NodoAVL<T> root, ListaCD<T> nodos) {`,
    `    if (root == null) return;`,
    `    inOrden(root.getIzq(), nodos);`,
    `    nodos.insertarAlFinal(root.getInfo());`,
    `    inOrden(root.getDer(), nodos);`,
    `}`,
  ],

  getPreOrder: [
    `/**`,
    ` * Recorrido preOrden: nodo → izquierda → derecha.`,
    ` */`,
    `private void preOrden(NodoAVL<T> root, ListaCD<T> nodos) {`,
    `    if (root == null) return;`,
    `    nodos.insertarAlFinal(root.getInfo());`,
    `    preOrden(root.getIzq(), nodos);`,
    `    preOrden(root.getDer(), nodos);`,
    `}`,
  ],

  getPostOrder: [
    `/**`,
    ` * Recorrido postOrden: izquierda → derecha → nodo.`,
    ` */`,
    `private void postOrden(NodoAVL<T> root, ListaCD<T> nodos) {`,
    `    if (root == null) return;`,
    `    postOrden(root.getIzq(), nodos);`,
    `    postOrden(root.getDer(), nodos);`,
    `    nodos.insertarAlFinal(root.getInfo());`,
    `}`,
  ],

  getLevelOrder: [
    `/**`,
    ` * Recorrido por niveles (BFS).`,
    ` */`,
    `public ListaCD<T> getLevelOrder(NodoAVL<T> root) {`,
    `    ListaCD<T> nodos = new ListaCD<T>();`,
    `    if (root == null) return nodos;`,
    `    Cola<NodoAVL<T>> q = new Cola<NodoAVL<T>>();`,
    `    q.encolar(root);`,
    `    while (!q.esVacia()) {`,
    `        NodoAVL<T> x = q.decolar();`,
    `        nodos.insertarAlFinal(x.getInfo());`,
    `        if (x.getIzq() != null) q.encolar(x.getIzq());`,
    `        if (x.getDer() != null) q.encolar(x.getDer());`,
    `    }`,
    `    return nodos;`,
    `}`,
  ],

  clean: [
    `/**`,
    ` * Vacía completamente el árbol AVL.`,
    ` */`,
    `public void clean() {`,
    `    this.raiz = null;`,
    `}`,
  ],
});
