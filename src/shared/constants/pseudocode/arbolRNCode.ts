// pseudocode/rb/getArbolRNCode.ts
import { OperationCode } from "./typesPseudoCode";

export const getArbolRNCode = (): OperationCode => ({
  insert: [
    `/**`,
    ` * Inserta un valor en el Árbol Roji-Negro.`,
    ` * Regla: el nuevo nodo se inserta ROJO y luego se corrige (fix-up).`,
    ` */`,
    `public void insert(T valor) {`,
    `    NodoRN<T> z = new NodoRN<T>(valor);`,
    `    z.color = ROJO;`,
    `    // Inserción BST estándar`,
    `    NodoRN<T> y = null;`,
    `    NodoRN<T> x = raiz;`,
    `    while (x != null) {`,
    `        y = x;`,
    `        if (z.info.compareTo(x.info) < 0) x = x.izq;`,
    `        else if (z.info.compareTo(x.info) > 0) x = x.der;`,
    `        else return; // duplicado: no insertamos`,
    `    }`,
    `    z.padre = y;`,
    `    if (y == null) raiz = z;`,
    `    else if (z.info.compareTo(y.info) < 0) y.izq = z;`,
    `    else y.der = z;`,
    ``,
    `    // Corrección de propiedades Roji-Negro`,
    `    insertFixup(z);`,
    `}`,
    ``,
    `private void insertFixup(NodoRN<T> z) {`,
    `    while (z.padre != null && z.padre.color == ROJO) {`,
    `        if (z.padre == z.padre.padre.izq) {`,
    `            NodoRN<T> y = z.padre.padre.der; // tío`,
    `            if (y != null && y.color == ROJO) {`,
    `                // Caso 1: padre y tío rojos -> recolorear`,
    `                z.padre.color = NEGRO;`,
    `                y.color = NEGRO;`,
    `                z.padre.padre.color = ROJO;`,
    `                z = z.padre.padre;`,
    `            } else {`,
    `                if (z == z.padre.der) {`,
    `                    // Caso 2: triángulo -> rotación izquierda en padre`,
    `                    z = z.padre;`,
    `                    rotacionIzquierda(z);`,
    `                }`,
    `                // Caso 3: línea -> rotación derecha en abuelo`,
    `                z.padre.color = NEGRO;`,
    `                z.padre.padre.color = ROJO;`,
    `                rotacionDerecha(z.padre.padre);`,
    `            }`,
    `        } else {`,
    `            // Simétrico (padre es hijo derecho del abuelo)`,
    `            NodoRN<T> y = z.padre.padre.izq;`,
    `            if (y != null && y.color == ROJO) {`,
    `                z.padre.color = NEGRO;`,
    `                y.color = NEGRO;`,
    `                z.padre.padre.color = ROJO;`,
    `                z = z.padre.padre;`,
    `            } else {`,
    `                if (z == z.padre.izq) {`,
    `                    z = z.padre;`,
    `                    rotacionDerecha(z);`,
    `                }`,
    `                z.padre.color = NEGRO;`,
    `                z.padre.padre.color = ROJO;`,
    `                rotacionIzquierda(z.padre.padre);`,
    `            }`,
    `        }`,
    `    }`,
    `    raiz.color = NEGRO; // la raíz siempre negra`,
    `}`,
  ],

  delete: [
    `/**`,
    ` * Elimina un valor del Árbol Roji-Negro.`,
    ` * Se hace delete BST + fix-up para restaurar las propiedades.`,
    ` */`,
    `public void delete(T valor) {`,
    `    NodoRN<T> z = buscarNodo(raiz, valor);`,
    `    if (z == null) return;`,
    ``,
    `    NodoRN<T> y = z;`,
    `    Color yColorOriginal = y.color;`,
    `    NodoRN<T> x;`,
    `    if (z.izq == null) {`,
    `        x = z.der;`,
    `        transplant(z, z.der);`,
    `    } else if (z.der == null) {`,
    `        x = z.izq;`,
    `        transplant(z, z.izq);`,
    `    } else {`,
    `        y = minimo(z.der);`,
    `        yColorOriginal = y.color;`,
    `        x = y.der;`,
    `        if (y.padre == z) {`,
    `            if (x != null) x.padre = y;`,
    `        } else {`,
    `            transplant(y, y.der);`,
    `            y.der = z.der;`,
    `            y.der.padre = y;`,
    `        }`,
    `        transplant(z, y);`,
    `        y.izq = z.izq;`,
    `        y.izq.padre = y;`,
    `        y.color = z.color;`,
    `    }`,
    `    if (yColorOriginal == NEGRO) deleteFixup(x);`,
    `}`,
    ``,
    `private void deleteFixup(NodoRN<T> x) {`,
    `    while (x != raiz && colorDe(x) == NEGRO) {`,
    `        if (x == x.padre.izq) {`,
    `            NodoRN<T> w = x.padre.der; // hermano`,
    `            if (colorDe(w) == ROJO) {`,
    `                // Caso 1`,
    `                w.color = NEGRO;`,
    `                x.padre.color = ROJO;`,
    `                rotacionIzquierda(x.padre);`,
    `                w = x.padre.der;`,
    `            }`,
    `            if (colorDe(w.izq) == NEGRO && colorDe(w.der) == NEGRO) {`,
    `                // Caso 2`,
    `                w.color = ROJO;`,
    `                x = x.padre;`,
    `            } else {`,
    `                if (colorDe(w.der) == NEGRO) {`,
    `                    // Caso 3`,
    `                    if (w.izq != null) w.izq.color = NEGRO;`,
    `                    w.color = ROJO;`,
    `                    rotacionDerecha(w);`,
    `                    w = x.padre.der;`,
    `                }`,
    `                // Caso 4`,
    `                w.color = x.padre.color;`,
    `                x.padre.color = NEGRO;`,
    `                if (w.der != null) w.der.color = NEGRO;`,
    `                rotacionIzquierda(x.padre);`,
    `                x = raiz;`,
    `            }`,
    `        } else {`,
    `            // Simétrico (x es hijo derecho)`,
    `            NodoRN<T> w = x.padre.izq;`,
    `            if (colorDe(w) == ROJO) {`,
    `                w.color = NEGRO;`,
    `                x.padre.color = ROJO;`,
    `                rotacionDerecha(x.padre);`,
    `                w = x.padre.izq;`,
    `            }`,
    `            if (colorDe(w.der) == NEGRO && colorDe(w.izq) == NEGRO) {`,
    `                w.color = ROJO;`,
    `                x = x.padre;`,
    `            } else {`,
    `                if (colorDe(w.izq) == NEGRO) {`,
    `                    if (w.der != null) w.der.color = NEGRO;`,
    `                    w.color = ROJO;`,
    `                    rotacionIzquierda(w);`,
    `                    w = x.padre.izq;`,
    `                }`,
    `                w.color = x.padre.color;`,
    `                x.padre.color = NEGRO;`,
    `                if (w.izq != null) w.izq.color = NEGRO;`,
    `                rotacionDerecha(x.padre);`,
    `                x = raiz;`,
    `            }`,
    `        }`,
    `    }`,
    `    if (x != null) x.color = NEGRO;`,
    `}`,
    ``,
    `// Utilidades:`,
    `private void transplant(NodoRN<T> u, NodoRN<T> v) {`,
    `    if (u.padre == null) raiz = v;`,
    `    else if (u == u.padre.izq) u.padre.izq = v;`,
    `    else u.padre.der = v;`,
    `    if (v != null) v.padre = u.padre;`,
    `}`,
    `private Color colorDe(NodoRN<T> n) { return (n == null) ? NEGRO : n.color; }`,
  ],

  search: [
    `/** Busca un valor (propiedad BST). */`,
    `public boolean search(T valor) {`,
    `    NodoRN<T> x = raiz;`,
    `    while (x != null) {`,
    `        int cmp = valor.compareTo(x.info);`,
    `        if (cmp == 0) return true;`,
    `        x = (cmp < 0) ? x.izq : x.der;`,
    `    }`,
    `    return false;`,
    `}`,
  ],

  getInOrder: [
    `/** In-Orden: izq -> nodo -> der */`,
    `private void inOrden(NodoRN<T> n, ListaCD<T> out) {`,
    `    if (n == null) return;`,
    `    inOrden(n.izq, out);`,
    `    out.insertarAlFinal(n.info);`,
    `    inOrden(n.der, out);`,
    `}`,
  ],

  getPreOrder: [
    `/** Pre-Orden: nodo -> izq -> der */`,
    `private void preOrden(NodoRN<T> n, ListaCD<T> out) {`,
    `    if (n == null) return;`,
    `    out.insertarAlFinal(n.info);`,
    `    preOrden(n.izq, out);`,
    `    preOrden(n.der, out);`,
    `}`,
  ],

  getPostOrder: [
    `/** Post-Orden: izq -> der -> nodo */`,
    `private void postOrden(NodoRN<T> n, ListaCD<T> out) {`,
    `    if (n == null) return;`,
    `    postOrden(n.izq, out);`,
    `    postOrden(n.der, out);`,
    `    out.insertarAlFinal(n.info);`,
    `}`,
  ],

  getLevelOrder: [
    `/** Recorrido por niveles (BFS). */`,
    `public ListaCD<T> getLevelOrder(NodoRN<T> root) {`,
    `    ListaCD<T> out = new ListaCD<T>();`,
    `    if (root == null) return out;`,
    `    Cola<NodoRN<T>> q = new Cola<>();`,
    `    q.encolar(root);`,
    `    while (!q.esVacia()) {`,
    `        NodoRN<T> u = q.decolar();`,
    `        out.insertarAlFinal(u.info);`,
    `        if (u.izq != null) q.encolar(u.izq);`,
    `        if (u.der != null) q.encolar(u.der);`,
    `    }`,
    `    return out;`,
    `}`,
  ],

  findMin: [
    `/** Devuelve el mínimo (clave más a la izquierda). */`,
    `public T findMin() {`,
    `    NodoRN<T> x = raiz;`,
    `    if (x == null) return null;`,
    `    while (x.izq != null) x = x.izq;`,
    `    return x.info;`,
    `}`,
  ],

  findMax: [
    `/** Devuelve el máximo (clave más a la derecha). */`,
    `public T findMax() {`,
    `    NodoRN<T> x = raiz;`,
    `    if (x == null) return null;`,
    `    while (x.der != null) x = x.der;`,
    `    return x.info;`,
    `}`,
  ],

  clean: [
    `/**`,
    ` * Vacía completamente el Árbol Roji-Negro.`,
    ` */`,
    `public void clean() {`,
    `    this.raiz = null;`,
    `}`,
  ],
});
