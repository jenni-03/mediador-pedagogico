import { OperationCode } from "./typesPseudoCode";

/**
 * Pseudocódigo de Árbol B+ (grado mínimo t ≥ 2)
 *
 * BPlusNode:
 *   keys: lista ordenada de T
 *   child: arreglo de hijos (solo si !leaf)  // child.length = keys.length + 1
 *   leaf: boolean
 *   nextLeaf: ref a la hoja derecha (o null)
 *   t: grado mínimo
 *
 * Propiedades:
 *  - Toda hoja al mismo nivel (altura uniforme).
 *  - Todo nodo interno (excepto la raíz) tiene entre t-1 y 2t-1 claves.
 *  - Toda hoja (excepto la raíz si es la única) tiene entre t-1 y 2t-1 claves.
 *  - En B+ las claves "de datos" viven en HOJAS; los internos sólo enrutan.
 *  - Hojas encadenadas por nextLeaf para recorridos/rangos eficientes.
 */
export const getArbolBPlusCode = (): OperationCode => ({
  insert: [
    `/** Inserta una clave k en el B+. Duplica la separadora al subir en splits de hoja. */`,
    `public void insert(T {0}) {`,
    `    if (root == null) {`,
    `        root = new BPlusNode(t, /*leaf=*/true);`,
    `        root.keys.add({0});`,
    `        return;`,
    `    }`,
    `    if (isFull(root)) {`,
    `        BPlusNode s = new BPlusNode(t, /*leaf=*/false);`,
    `        s.child[0] = root;`,
    `        splitChild(s, 0); // decide split de hoja o interno según s.child[0].leaf`,
    `        root = s;`,
    `    }`,
    `    insertNonFull(root, {0});`,
    `}`,
    ``,
    `/** Inserción estándar B+ en un subárbol cuya raíz NO está llena. */`,
    `private void insertNonFull(BPlusNode x, T {0}) {`,
    `    if (x.leaf) {`,
    `        // Insertar en orden dentro de la hoja`,
    `        int i = lowerBound(x.keys, {0});`,
    `        x.keys.add(i, {0});`,
    `        // si se desborda, tratar arriba (el caller garantiza x no lleno en entrada)`,
    `    } else {`,
    `        // Descenso por intervalo`,
    `        int i = childIndexToDescend(x.keys, {0});`,
    `        if (isFull(x.child[i])) {`,
    `            splitChild(x, i);`,
    `            // tras split, decidir si bajamos a i o i+1 según separadora`,
    `            if ({0}.compareTo(x.keys.get(i)) >= 0) i++;`,
    `        }`,
    `        insertNonFull(x.child[i], {0});`,
    `    }`,
    `}`,
    ``,
    `/** Divide el hijo y = x.child[i].`,
    ` *  - Si y es HOJA:`,
    ` *      z recibe las últimas (t) o (t-1) claves (según convención),`,
    ` *      duplicar la clave separadora en el PADRE (NO se elimina de la hoja),`,
    ` *      enlazar hojas: y.nextLeaf -> z -> antiguoSiguiente.`,
    ` *  - Si y es INTERNO:`,
    ` *      promover la clave media (se elimina de y) y dividir en y (izq) y z (der). */`,
    `private void splitChild(BPlusNode x, int i) {`,
    `    BPlusNode y = x.child[i];`,
    `    BPlusNode z = new BPlusNode(t, y.leaf);`,
    `    int mid = y.keys.size() / 2;`,
    `    if (y.leaf) {`,
    `        // z <- claves [mid .. end)`,
    `        moveRange(y.keys, mid, y.keys.size(), z.keys);`,
    `        // ajustar lista de hojas`,
    `        z.nextLeaf = y.nextLeaf;`,
    `        y.nextLeaf = z;`,
    `        // separadora a insertar/duplicar en x`,
    `        T sep = z.keys.get(0); // en B+ la separadora es la PRIMERA de z`,
    `        x.keys.add(i, sep);`,
    `        shiftRight(x.child, i+1);`,
    `        x.child[i+1] = z;`,
    `    } else {`,
    `        // interno: promover la media y repartir hijos`,
    `        T up = y.keys.get(mid);`,
    `        // z <- claves (mid+1 .. end)`,
    `        moveRange(y.keys, mid+1, y.keys.size(), z.keys);`,
    `        // niños derechos a z`,
    `        moveRange(y.child, mid+1, mid+1 + z.keys.size() + 1, z.child);`,
    `        // recortar y: claves [0..mid-1] y niños [0..mid]`,
    `        shrinkTo(y.keys, 0, mid);`,
    `        shrinkTo(y.child, 0, mid+1);`,
    `        // subir "up" al padre`,
    `        x.keys.add(i, up);`,
    `        shiftRight(x.child, i+1);`,
    `        x.child[i+1] = z;`,
    `    }`,
    `}`,
  ],

  delete: [
    `/** Elimina k del B+. Borra en hoja; repara hojas/intervalos y ajusta separadoras. */`,
    `public void delete(T {0}) {`,
    `    if (root == null) return;`,
    `    deleteFrom(root, {0});`,
    `    // Contracción de raíz`,
    `    if (!root.leaf && root.keys.isEmpty()) root = root.child[0];`,
    `    if (root.leaf && root.keys.isEmpty()) root = null;`,
    `}`,
    ``,
    `private void deleteFrom(BPlusNode x, T {0}) {`,
    `    if (x.leaf) {`,
    `        int i = indexOf(x.keys, {0});`,
    `        if (i == -1) return;`,
    `        boolean firstKeyChanged = (i == 0);`,
    `        x.keys.remove(i);`,
    `        if (firstKeyChanged) updateSeparatorUpwards(x); // si cambió la primera clave de la hoja`,
    `        if (underMin(x) && x != root) fixLeafUnderflow(x);`,
    `    } else {`,
    `        // bajar hasta la hoja correspondiente`,
    `        int i = childIndexToDescend(x.keys, {0});`,
    `        BPlusNode c = x.child[i];`,
    `        deleteFrom(c, {0});`,
    `        // si el hijo quedó por debajo del mínimo, reparar en el nivel interno`,
    `        if (!c.leaf && underMin(c)) fixInternalUnderflow(x, i);`,
    `        // Nota: fixLeafUnderflow se llamó en la rama de hoja si fue necesario`,
    `    }`,
    `}`,
    ``,
    `/** Si una HOJA quedó por debajo del mínimo: intentar pedir a hermano o fusionar. */`,
    `private void fixLeafUnderflow(BPlusNode leaf) {`,
    `    ParentRef pr = findParent(root, leaf); // (p, idx)`,
    `    if (pr == null) return;`,
    `    BPlusNode p = pr.node; int i = pr.index;`,
    `    // hermano izquierdo`,
    `    if (i > 0 && p.child[i-1].keys.size() > minLeafKeys()) {`,
    `        borrowFromPrevLeaf(p, i);`,
    `        updateSeparatorAfterBorrow(p, i);`,
    `        return;`,
    `    }`,
    `    // hermano derecho`,
    `    if (i < p.keys.size() && p.child[i+1].keys.size() > minLeafKeys()) {`,
    `        borrowFromNextLeaf(p, i);`,
    `        updateSeparatorAfterBorrow(p, i+1);`,
    `        return;`,
    `    }`,
    `    // fusionar con izquierdo o derecho`,
    `    if (i < p.keys.size()) mergeLeaves(p, i); else mergeLeaves(p, i-1);`,
    `}`,
    ``,
    `private void borrowFromPrevLeaf(BPlusNode p, int i) {`,
    `    BPlusNode L = p.child[i-1], C = p.child[i];`,
    `    // mover última clave de L a la cabeza de C`,
    `    C.keys.add(0, L.keys.remove(L.keys.size()-1));`,
    `}`,
    ``,
    `private void borrowFromNextLeaf(BPlusNode p, int i) {`,
    `    BPlusNode C = p.child[i], R = p.child[i+1];`,
    `    // mover primera clave de R al final de C`,
    `    C.keys.add(R.keys.remove(0));`,
    `}`,
    ``,
    `private void mergeLeaves(BPlusNode p, int i) {`,
    `    BPlusNode L = p.child[i], R = p.child[i+1];`,
    `    // concatenar claves y reparar enlaces`,
    `    for (T v : R.keys) L.keys.add(v);`,
    `    L.nextLeaf = R.nextLeaf;`,
    `    // quitar separadora p.keys[i] y el hijo R`,
    `    p.keys.remove(i);`,
    `    removeChildAt(p.child, i+1);`,
    `    if (p != root && underMinInternal(p)) fixInternalUnderflowParent(p);`,
    `}`,
    ``,
    `/** Si un INTERNO quedó por debajo del mínimo tras borrar en subárbol. */`,
    `private void fixInternalUnderflow(BPlusNode p, int i) {`,
    `    if (i > 0 && p.child[i-1].keys.size() > minInternalKeys()) {`,
    `        borrowFromLeftInternal(p, i);`,
    `        return;`,
    `    }`,
    `    if (i < p.keys.size() && p.child[i+1].keys.size() > minInternalKeys()) {`,
    `        borrowFromRightInternal(p, i);`,
    `        return;`,
    `    }`,
    `    if (i < p.keys.size()) mergeInternals(p, i); else mergeInternals(p, i-1);`,
    `}`,
    ``,
    `private void borrowFromLeftInternal(BPlusNode p, int i) {`,
    `    BPlusNode L = p.child[i-1], C = p.child[i];`,
    `    // rotar una clave de p hacia C y mover la mayor de L hacia p`,
    `    C.keys.add(0, p.keys.get(i-1));`,
    `    p.keys.set(i-1, L.keys.remove(L.keys.size()-1));`,
    `    // mover el último hijo de L como primer hijo de C`,
    `    shiftRight(C.child, 0);`,
    `    C.child[0] = L.child.popBack();`,
    `}`,
    ``,
    `private void borrowFromRightInternal(BPlusNode p, int i) {`,
    `    BPlusNode C = p.child[i], R = p.child[i+1];`,
    `    C.keys.add(p.keys.get(i));`,
    `    p.keys.set(i, R.keys.remove(0));`,
    `    C.child.pushBack(R.child.remove(0));`,
    `}`,
    ``,
    `private void mergeInternals(BPlusNode p, int i) {`,
    `    BPlusNode L = p.child[i], R = p.child[i+1];`,
    `    // bajar separadora entre L y R`,
    `    L.keys.add(p.keys.remove(i));`,
    `    // concatenar claves e hijos de R`,
    `    for (T v : R.keys) L.keys.add(v);`,
    `    for (Node h : R.child) L.child.pushBack(h);`,
    `    removeChildAt(p.child, i+1);`,
    `}`,
    ``,
    `/** Si cambia la PRIMERA clave de una hoja, actualizar separadoras en ancestros. */`,
    `private void updateSeparatorUpwards(BPlusNode leaf) {`,
    `    T newFirst = leaf.keys.isEmpty() ? null : leaf.keys.get(0);`,
    `    // subir y actualizar la primera clave igual al viejo valor que apuntaba a esta hoja`,
    `    updateSeparators(root, leaf, newFirst);`,
    `}`,
  ],

  search: [
    `/** Busca k en el B+: baja por internos y verifica en hoja. */`,
    `public boolean search(T {0}) {`,
    `    BPlusNode x = root;`,
    `    while (x != null && !x.leaf) {`,
    `        int i = childIndexToDescend(x.keys, {0});`,
    `        x = x.child[i];`,
    `    }`,
    `    if (x == null) return false;`,
    `    int i = lowerBound(x.keys, {0});`,
    `    return (i < x.keys.size() && x.keys.get(i).equals({0}));`,
    `}`,
  ],

  range: [
    `/** Emite claves en [from, to] recorriendo hojas con nextLeaf. */`,
    `public ListaCD<T> range(T {0}, T {1}) {`,
    `    ListaCD<T> out = new ListaCD<>();`,
    `    if (root == null || {0}.compareTo({1}) > 0) return out;`,
    `    // ubicar hoja de inicio`,
    `    BPlusNode x = root;`,
    `    while (!x.leaf) {`,
    `        int i = childIndexToDescend(x.keys, {0});`,
    `        x = x.child[i];`,
    `    }`,
    `    int i = lowerBound(x.keys, {0});`,
    `    while (x != null) {`,
    `        while (i < x.keys.size() && x.keys.get(i).compareTo({1}) <= 0) {`,
    `            out.insertarAlFinal(x.keys.get(i));`,
    `            i++;`,
    `        }`,
    `        if (i < x.keys.size()) break; // el resto ya supera '{1}'`,
    `        x = x.nextLeaf;`,
    `        i = 0;`,
    `    }`,
    `    return out;`,
    `}`,
  ],

  scanFrom: [
    `/** Emite hasta 'limit' claves comenzando en 'start' (inclusive). */`,
    `public ListaCD<T> scanFrom(T {0}, int {1}) {`,
    `    ListaCD<T> out = new ListaCD<>();`,
    `    if (root == null || {1} <= 0) return out;`,
    `    BPlusNode x = root;`,
    `    while (!x.leaf) {`,
    `        int i = childIndexToDescend(x.keys, {0});`,
    `        x = x.child[i];`,
    `    }`,
    `    int i = lowerBound(x.keys, {0});`,
    `    int left = {1};`,
    `    while (x != null && left > 0) {`,
    `        while (i < x.keys.size() && left > 0) {`,
    `            out.insertarAlFinal(x.keys.get(i));`,
    `            i++; left--;`,
    `        }`,
    `        x = x.nextLeaf;`,
    `        i = 0;`,
    `    }`,
    `    return out;`,
    `}`,
  ],

  getInOrder: [
    `/** In-Order para UI: recorrer todas las hojas por nextLeaf y emitir sus claves. */`,
    `public void inOrderUI(ListaCD<T> out) {`,
    `    if (root == null) return;`,
    `    // ir a la hoja más a la izquierda`,
    `    BPlusNode x = root;`,
    `    while (!x.leaf) x = x.child[0];`,
    `    // recorrer por el "belt" de hojas`,
    `    while (x != null) {`,
    `        for (int i=0; i<x.keys.size(); i++) out.insertarAlFinal(x.keys.get(i));`,
    `        x = x.nextLeaf;`,
    `    }`,
    `}`,
  ],

  getLevelOrder: [
    `/** BFS de nodos (útil para depurar estructura interna). Emite keys por nodo visitado. */`,
    `public ListaCD<T> getLevelOrder() {`,
    `    ListaCD<T> out = new ListaCD<>();`,
    `    if (root == null) return out;`,
    `    Cola<BPlusNode> q = new Cola<>();`,
    `    q.encolar(root);`,
    `    while (!q.esVacia()) {`,
    `        BPlusNode x = q.decolar();`,
    `        for (int i=0; i<x.keys.size(); i++) out.insertarAlFinal(x.keys.get(i));`,
    `        if (!x.leaf)`,
    `            for (int i=0; i<=x.keys.size(); i++) q.encolar(x.child[i]);`,
    `    }`,
    `    return out;`,
    `}`,
  ],

  clean: [
    `/** Vacía completamente el Árbol B+. */`,
    `public void clean() {`,
    `    root = null;`,
    `}`,
  ],
});
